IMPLEMENTATION MODULE M2RM; (* JG 2.11.85 / NW 17.12.85 *)  FROM SYSTEM IMPORT ADDRESS, WORD, VAL;  FROM FileSystem IMPORT File, Response, Lookup, Close,    ReadChar, WriteChar, ReadWord, WriteWord;  FROM FileUtil IMPORT Path, ExtLookup, GetCurrentPath, AddPath, GetPos;  FROM M2SM IMPORT source, IdBuf, id, Diff, Mark;  FROM M2DM IMPORT ObjClass, Object, ObjPtr, StrForm, Structure, StrPtr,    Parameter, ParPtr, PDesc, Key, KeyPtr, undftyp, booltyp, chartyp, inttyp,    cardtyp, dbltyp, lcardtyp, realtyp, lrltyp, stringtyp, bytetyp, wordtyp,    addrtyp, bitstyp, proctyp, notyp, mainmod, ALLOCATE, ResetHeap, Standard;  FROM M2LM IMPORT pc, AllocBounds, AllocString;  CONST REFFILE = 334B;    CTL = -5000B; anchor = 0; ModTag = 1; ProcTag = 2; RefTag = 3; linkage = 4;    STR = -6000B; enum = 0; range = 1; pointer = 2; set = 3; procTyp = 4;          funcTyp = 5; array = 6; dynarr = 7; record = 8; opaque = 9;    CMP = -7000B; parref = 0; par = 1; field = 2;    OBJ = -10000B; varref = 0; var = 1; const = 2; string = 3; type = 4;          proc = 5; func = 6; module = 7; svc = 8; svcfunc = 9;    maxM = 64; minS = 32 (*first non-standard structure*); maxS = 1024;  VAR CurStr: INTEGER;      f: File; err: BOOLEAN;      Temps, Fields: ObjPtr;      Params, lastPar: ParPtr;      oldPos: LONGINT;      mark: ADDRESS;      markId: INTEGER;  PROCEDURE ReadId;    VAR i, L: INTEGER; ch: CHAR;  BEGIN i := id;    ReadChar(f, ch); IdBuf[i] := ch; INC(i); L := ORD(ch)-1;    WHILE L > 0 DO      ReadChar(f, ch); IdBuf[i] := ch; INC(i); DEC(L)    END;    id := i  END ReadId;  PROCEDURE InitRef;  BEGIN    WITH mainmod^ DO left := NIL; right := NIL; next := NIL END;    ALLOCATE(ModList, SIZE(Object)); ALLOCATE(Temps, SIZE(Object));    ALLOCATE(Fields, SIZE(Object)); ALLOCATE(Params, SIZE(Parameter));    WITH ModList^ DO class := Header;      next := mainmod; last := mainmod; left := NIL; right := NIL    END;    ModNo := 1;    WITH Temps^ DO class := Header;      next := NIL; last := Temps; left := NIL; right := NIL    END;    WITH Fields^ DO class := Header;      next := NIL; last := Fields; left := NIL; right := NIL    END;    Params^.next := NIL; lastPar := Params  END InitRef;  PROCEDURE Insert(root, obj: ObjPtr): ObjPtr;    VAR ob0, ob1: ObjPtr; d: INTEGER;  BEGIN ob0 := root; ob1 := ob0^.right; d := 1;    LOOP      IF ob1 # NIL THEN        d := Diff(obj^.name, ob1^.name);        IF d < 0 THEN ob0 := ob1; ob1 := ob1^.left        ELSIF d > 0 THEN ob0 := ob1; ob1 := ob1^.right        ELSE EXIT        END      ELSE ob1 := obj;        IF d < 0 THEN ob0^.left := ob1 ELSE ob0^.right := ob1 END;        ob1^.left := NIL; ob1^.right := NIL; EXIT      END    END;    RETURN ob1  END Insert;  PROCEDURE MarkHeap;  BEGIN    markId := id; ALLOCATE(mark, 0);  END MarkHeap;  PROCEDURE Reset;  BEGIN    id := markId; ResetHeap(mark);  END Reset;  PROCEDURE InRef(VAR filename: ARRAY OF CHAR; VAR hdr: ObjPtr;                  VAR adr, pno: INTEGER);    VAR GlbMod: ARRAY [0..maxM] OF ObjPtr;        Struct: ARRAY [0..maxS] OF StrPtr;        CurMod, FileType, block, m, p, s: INTEGER;        newobj, obj: ObjPtr;        newpar: ParPtr; newstr: StrPtr;        ch: CHAR; ok: BOOLEAN; path: Path;  BEGIN    ExtLookup(f, filename, FALSE, ok);    IF ok THEN      GetCurrentPath(path);      AddPath(path, filename, filename);    END;    IF ok THEN ReadWord(f, FileType);      IF FileType = REFFILE THEN        Struct[1] := undftyp; Struct[2] := booltyp; Struct[3] := chartyp;        Struct[4] := inttyp; Struct[5] := cardtyp; Struct[6] := dbltyp;        Struct[7] := realtyp; Struct[8] := lrltyp; Struct[9] := bitstyp;        Struct[10] := proctyp; Struct[11] := stringtyp;        Struct[12] := addrtyp; Struct[13] := bytetyp; Struct[14] := wordtyp;        Struct[15] := lcardtyp;        CurMod := 0; CurStr := minS; err := FALSE;        MarkHeap;        LOOP ReadWord(f, block);          IF block < CMP THEN block := block - OBJ;            IF block > svcfunc THEN err := TRUE; Mark(86); EXIT END;            ALLOCATE(newobj, SIZE(Object)); m := 0;            WITH newobj^ DO next := NIL;              CASE block OF                var    : class := Var; ReadWord(f, s); typ := Struct[s];                         varpar := FALSE; vmod := GlbMod[0]^.right^.modno;                         ReadWord(f, vlev); ReadWord(f, vadr)              | const  : class := Const; ReadWord(f, s); typ := Struct[s];                         ReadWord(f, m);                         ReadChar(f, ch);                         CASE ORD(ch) OF                           2: ReadChar(f, ch); conval.Ch := ch;                         | 3: ReadWord(f, conval.I);                         | 5: ReadWord(f, conval.D0); ReadWord(f, conval.D1);                         | 9: ReadWord(f, conval.D0); ReadWord(f, conval.D1);                              ReadWord(f, conval.D2); ReadWord(f, conval.D3);                         ELSE                           Mark(86);                         END;              | string : class := Const; ReadWord(f, s); typ := Struct[s];                         conval.D2 := id; ReadId;                         AllocString(conval.D2, conval.D0, conval.D1);                         (*conval.D1 := id - conval.D2; conval.D0 := -1*)              | type   : class := Typ; ReadWord(f, s); typ := Struct[s];                         IF typ^.strobj = NIL THEN typ^.strobj := newobj END;                         ReadWord(f, m); mod := GlbMod[m]^.right              | proc, func : class := Proc;                         IF block = func THEN ReadWord(f, s); typ := Struct[s]                           ELSE typ := notyp                         END;                         ALLOCATE(pd, SIZE(PDesc));                         ReadWord(f, pd^.num); ReadWord(f, pd^.lev);                         ReadWord(f, pd^.adr); ReadWord(f, pd^.size);                         pd^.forward := FALSE; pd^.exp := FALSE;                      (* pd^.extern := TRUE; pd^.link := 0; *)                         firstLocal := NIL; firstParam := Params^.next;                         Params^.next := NIL; lastPar := Params;                         pmod := GlbMod[0]^.right^.modno              | svc, svcfunc: class := Code;                         IF block = svcfunc THEN ReadWord(f, s); typ := Struct[s]                           ELSE typ := notyp                         END;                         ReadWord(f, cnum); std := NonStand;                         firstArg := Params^.next;                         Params^.next := NIL; lastPar := Params              END;              name := id; ReadId; exported := TRUE;              obj := Insert(GlbMod[m]^.right, newobj);              IF obj = newobj THEN (*new object*)                GlbMod[m]^.last^.next := newobj; GlbMod[m]^.last := newobj;                IF (class = Const) & (typ^.form = Enum) THEN                  conval.prev := typ^.ConstLink; typ^.ConstLink := newobj                END;                MarkHeap              ELSE                IF obj^.class = Typ THEN Struct[s] := obj^.typ END;                Reset              END            END          ELSIF block < STR THEN block := block - CMP;            IF block > field THEN err := TRUE; Mark(86); EXIT END;            IF block = field THEN              ALLOCATE(newobj, SIZE(Object));              WITH newobj^ DO                class := Field; next := NIL;                ReadWord(f, s); typ := Struct[s];                ReadWord(f, offset); name := id; ReadId;                newobj := Insert(Fields, newobj)              END;              Fields^.last^.next := newobj; Fields^.last := newobj            ELSE (*parameter*)              ALLOCATE(newpar, SIZE(Parameter));              WITH newpar^ DO                next := NIL; ReadWord(f, s); typ := Struct[s];                varpar := block = parref;                lastPar^.next := newpar; lastPar := newpar              END            END          ELSIF block < CTL THEN block := block - STR;            IF block > opaque THEN err := TRUE; Mark(86); EXIT END;            ALLOCATE(newstr, SIZE(Structure));            WITH newstr^ DO              strobj := NIL; ReadWord(f, size); ref := 0;              CASE block OF                enum    : form := Enum; ReadWord(f, NofConst);                          ConstLink := NIL              | range   : form := Range;                          ReadWord(f, s); RBaseTyp := Struct[s];                          ReadWord(f, min); ReadWord(f, max);                          AllocBounds(min, max, size, BndAdr)              | pointer : form := Pointer; PBaseTyp := NIL;                          BaseId := 0;                          MarkHeap              | set     : form := Set; ReadWord(f, s);                          SBaseTyp := Struct[s]              | procTyp, funcTyp : form := ProcTyp;                          IF block = funcTyp THEN                            ReadWord(f, s); resTyp := Struct[s]                          ELSE resTyp := notyp                          END;                          firstPar := Params^.next;                          Params^.next := NIL; lastPar := Params              | array   : form := Array; ReadWord(f, s);                          ElemTyp := Struct[s]; dyn := FALSE;                          ReadWord(f, s); IndexTyp := Struct[s]              | dynarr  : form := Array; ReadWord(f, s);                          ElemTyp := Struct[s]; dyn := TRUE;                          IndexTyp := NIL              | record  : form := Record;                          firstFld := Fields^.right; Fields^.right := NIL;                          Fields^.next := NIL; Fields^.last := Fields              | opaque  : form := Opaque              END            END;            IF CurStr > maxS THEN err := TRUE; Mark(98); EXIT END;            Struct[CurStr] := newstr;            CurStr := CurStr + 1          ELSIF block < 0 THEN block := block - CTL;            IF block = linkage THEN ReadWord(f, s); ReadWord(f, p);              IF Struct[p]^.PBaseTyp # NIL THEN                Reset              ELSE Struct[p]^.PBaseTyp := Struct[s];                MarkHeap              END            ELSIF block = ModTag THEN (*main module*) ReadWord(f, m)            ELSIF block = anchor THEN              ALLOCATE(newobj, SIZE(Object));              WITH newobj^ DO                class := Module; typ := NIL; left := NIL; right := NIL;                ALLOCATE(key, SIZE(Key));                ReadWord(f, key^.k0); ReadWord(f, key^.k1); ReadWord(f, key^.k2);                firstObj := NIL; root := NIL; name := id; ReadId              END;              IF CurMod > maxM THEN Mark(96); EXIT END;              ALLOCATE(GlbMod[CurMod], SIZE(Object));              MarkHeap;              WITH GlbMod[CurMod]^ DO                class := Header; kind := Module; typ := NIL;                next := NIL; left := NIL; last := GlbMod[CurMod];                obj := ModList^.next; (*find mod*)                WHILE (obj # NIL) & (Diff(obj^.name, newobj^.name) # 0) DO                  obj := obj^.next                END;                IF obj # NIL THEN GlbMod[CurMod]^.right := obj;                  IF (CurMod = 0) & (obj = mainmod) THEN                    (*newobj is own definition module*)                    obj^.key^ := newobj^.key^                  ELSIF (obj^.key^.k0 # newobj^.key^.k0)                     OR (obj^.key^.k1 # newobj^.key^.k1)                     OR (obj^.key^.k2 # newobj^.key^.k2) THEN Mark(85)                  ELSIF (CurMod = 0) & (obj^.firstObj # NIL) THEN                    CurMod := 1; EXIT (*module already loaded*)                  END;                  Reset                ELSE GlbMod[CurMod]^.right := newobj;                  newobj^.next := NIL; newobj^.modno := ModNo; INC(ModNo);                  ModList^.last^.next := newobj; ModList^.last := newobj;                  MarkHeap                END              END;              CurMod := CurMod + 1            ELSIF block = RefTag THEN              ReadWord(f, adr); ReadWord(f, pno); EXIT            ELSE err := TRUE; Mark(86); EXIT            END          ELSE (*line block*) err := TRUE; Mark(86); EXIT          END        END;        IF NOT err & (CurMod # 0) THEN hdr := GlbMod[0];          hdr^.right^.root := hdr^.right^.right;          (*leave hdr^.right.right for later searches*)          hdr^.right^.firstObj := hdr^.next        ELSE hdr := NIL        END      ELSE Mark(86); hdr := NIL      END;      Close(f)    ELSE Mark(88); hdr := NIL    END  END InRef;  PROCEDURE WriteId(i: INTEGER);    VAR L: INTEGER;  BEGIN L := ORD(IdBuf[i]);    REPEAT WriteChar(RefFile, IdBuf[i]); INC(i); DEC(L)    UNTIL L = 0  END WriteId;  PROCEDURE OpenRef;    VAR obj: ObjPtr;  BEGIN WriteWord(RefFile, REFFILE);    obj := ModList^.next;    WHILE obj # NIL DO      WriteWord(RefFile, CTL+anchor);      WITH obj^ DO WriteWord(RefFile, key^.k0);        WriteWord(RefFile, key^.k1); WriteWord(RefFile, key^.k2);        WriteId(name)      END;      obj := obj^.next    END;    CurStr := minS;    oldPos := 0D  END OpenRef;  PROCEDURE OutPar(prm: ParPtr);  BEGIN    WHILE prm # NIL DO (*out param*)      WITH prm^ DO        IF varpar THEN WriteWord(RefFile, CMP+parref)          ELSE WriteWord(RefFile, CMP+par)        END;        WriteWord(RefFile, typ^.ref)      END;      prm := prm^.next    END  END OutPar;  PROCEDURE OutStr(str: StrPtr);    VAR obj: ObjPtr; par: ParPtr;    PROCEDURE OutFldStrs(fld: ObjPtr);    BEGIN      WHILE fld # NIL DO        IF fld^.typ^.ref = 0 THEN OutStr(fld^.typ) END;        fld := fld^.next      END    END OutFldStrs;    PROCEDURE OutFlds(fld: ObjPtr);    BEGIN      WHILE fld # NIL DO        WITH fld^ DO          WriteWord(RefFile, CMP+field); WriteWord(RefFile, typ^.ref);          WriteWord(RefFile, offset); WriteId(name)        END;        fld := fld^.next      END    END OutFlds;  BEGIN    WITH str^ DO      CASE form OF        Enum    : WriteWord(RefFile, STR+enum); WriteWord(RefFile, size);                  WriteWord(RefFile, NofConst)      | Range   : IF RBaseTyp^.ref = 0 THEN OutStr(RBaseTyp) END;                  WriteWord(RefFile, STR+range); WriteWord(RefFile, size);                  WriteWord(RefFile, RBaseTyp^.ref);                  WriteWord(RefFile, min); WriteWord(RefFile, max)      | Pointer : ALLOCATE(obj, SIZE(Object));                  WITH obj^ DO left := NIL; next := NIL;                    class := Temp; typ := PBaseTyp; baseref := CurStr;                    Temps^.last^.next := obj; Temps^.last := obj                  END;                  WriteWord(RefFile, STR+pointer); WriteWord(RefFile, size)      | Set     : IF SBaseTyp^.ref = 0 THEN OutStr(SBaseTyp) END;                  WriteWord(RefFile, STR+set); WriteWord(RefFile, size);                  WriteWord(RefFile, SBaseTyp^.ref)      | ProcTyp : par := firstPar;                  WHILE par # NIL DO (*out param structure*)                    IF par^.typ^.ref = 0 THEN OutStr(par^.typ) END;                    par := par^.next                  END;                  OutPar(firstPar);                  IF resTyp # notyp THEN                    IF resTyp^.ref = 0 THEN OutStr(resTyp) END;                    WriteWord(RefFile, STR+funcTyp); WriteWord(RefFile, size);                    WriteWord(RefFile, resTyp^.ref)                  ELSE WriteWord(RefFile, STR+procTyp); WriteWord(RefFile, size)                  END      | Array   : IF ElemTyp^.ref = 0 THEN OutStr(ElemTyp) END;                  IF dyn THEN WriteWord(RefFile, STR+dynarr);                    WriteWord(RefFile, size); WriteWord(RefFile, ElemTyp^.ref)                  ELSE                    IF IndexTyp^.ref = 0 THEN OutStr(IndexTyp) END;                    WriteWord(RefFile, STR+array); WriteWord(RefFile, size);                    WriteWord(RefFile, ElemTyp^.ref);                    WriteWord(RefFile, IndexTyp^.ref)                  END      | Record  : OutFldStrs(firstFld); OutFlds(firstFld);                  WriteWord(RefFile, STR+record); WriteWord(RefFile, size)      | Opaque  : WriteWord(RefFile, STR+opaque); WriteWord(RefFile, size)      END;      ref := CurStr; CurStr := CurStr + 1    END  END OutStr;  PROCEDURE OutExt(str: StrPtr);    VAR obj: ObjPtr; par: ParPtr;    PROCEDURE OutFlds(fld: ObjPtr);    BEGIN      WHILE fld # NIL DO        IF fld^.typ^.ref = 0 THEN OutExt(fld^.typ) END;        fld := fld^.next      END    END OutFlds;  BEGIN    WITH str^ DO      CASE form OF        Range   : IF RBaseTyp^.ref = 0 THEN OutExt(RBaseTyp) END      | Set     : IF SBaseTyp^.ref = 0 THEN OutExt(SBaseTyp) END      | ProcTyp : par := firstPar;                  WHILE par # NIL DO                    IF par^.typ^.ref = 0 THEN OutExt(par^.typ) END;                    par := par^.next                  END;                  IF (resTyp # notyp) & (resTyp^.ref = 0) THEN OutExt(resTyp) END      | Array   : IF ElemTyp^.ref = 0 THEN OutExt(ElemTyp) END;                  IF NOT dyn THEN OutExt(IndexTyp) END      | Record  : OutFlds(firstFld)      | Enum, Pointer, Opaque :      END;      IF (strobj # NIL) & (strobj^.mod^.modno # 0) THEN        IF ref = 0 THEN OutStr(str) END;        IF form = Enum THEN obj := ConstLink;          WHILE obj # NIL DO            WriteWord(RefFile, OBJ+const);            WriteWord(RefFile, ref);            WriteWord(RefFile, strobj^.mod^.modno);            WriteChar(RefFile, 2C); WriteChar(RefFile, obj^.conval.Ch);            WriteId(obj^.name);            obj := obj^.conval.prev          END        END;        WriteWord(RefFile, OBJ+type);        WriteWord(RefFile, ref);        WriteWord(RefFile, strobj^.mod^.modno);        WriteId(strobj^.name)      END    END  END OutExt;  PROCEDURE OutObj(obj: ObjPtr);    VAR par: ParPtr;  BEGIN    WITH obj^ DO      CASE class OF        Module : WriteWord(RefFile, OBJ+module); WriteWord(RefFile, modno)      | Proc   : par := firstParam;                 WHILE par # NIL DO                   IF par^.typ^.ref = 0 THEN OutExt(par^.typ) END;                   par := par^.next                 END;                 IF (typ # notyp) & (typ^.ref = 0) THEN OutExt(typ) END;                 par := firstParam;                 WHILE par # NIL DO (*out param structure*)                   IF par^.typ^.ref = 0 THEN OutStr(par^.typ) END;                   par := par^.next                 END;                 IF (typ # notyp) & (typ^.ref = 0) THEN OutStr(typ) END;                 OutPar(firstParam);                 IF typ # notyp THEN                   WriteWord(RefFile, OBJ+func); WriteWord(RefFile, typ^.ref)                 ELSE WriteWord(RefFile, OBJ+proc)                 END;                 WriteWord(RefFile, pd^.num); WriteWord(RefFile, pd^.lev);                 WriteWord(RefFile, pd^.adr); WriteWord(RefFile, pd^.size)      | Code   : par := firstArg;                 WHILE par # NIL DO                   IF par^.typ^.ref = 0 THEN OutExt(par^.typ) END;                   par := par^.next                 END;                 IF (typ # notyp) & (typ^.ref = 0) THEN OutExt(typ) END;                 par := firstArg;                 WHILE par # NIL DO (*out param structure*)                   IF par^.typ^.ref = 0 THEN OutStr(par^.typ) END;                   par := par^.next                 END;                 IF (typ # notyp) & (typ^.ref = 0) THEN OutStr(typ) END;                 OutPar(firstArg);                 IF typ # notyp THEN                   WriteWord(RefFile, OBJ+svcfunc); WriteWord(RefFile, typ^.ref)                 ELSE WriteWord(RefFile, OBJ+svc)                 END;                 WriteWord(RefFile,VAL(INTEGER,cnum))      | Const  : IF typ^.ref = 0 THEN OutExt(typ) END;                 IF typ^.ref = 0 THEN OutStr(typ) END;                 IF typ^.form = String THEN WriteWord(RefFile, OBJ+string);                   WriteWord(RefFile, typ^.ref); WriteId(conval.D2)                 ELSE WriteWord(RefFile, OBJ+const);                   WriteWord(RefFile, typ^.ref);                   WriteWord(RefFile, 0); (*main*)                   WriteChar(RefFile, VAL(CHAR,typ^.size+1));                   CASE typ^.size OF                     1: WriteChar(RefFile, conval.Ch);                   | 2: WriteWord(RefFile, conval.I);                   | 4: WriteWord(RefFile, conval.D0);                        WriteWord(RefFile, conval.D1);                   | 8: WriteWord(RefFile, conval.D0);                        WriteWord(RefFile, conval.D1);                        WriteWord(RefFile, conval.D2);                        WriteWord(RefFile, conval.D3);                   ELSE                   END;                 END      | Typ    : IF typ^.ref = 0 THEN OutExt(typ) END;                 IF typ^.ref = 0 THEN OutStr(typ) END;                 WriteWord(RefFile, OBJ+type);                 WriteWord(RefFile, typ^.ref); WriteWord(RefFile, 0) (*main*)      | Var    : IF typ^.ref = 0 THEN OutExt(typ) END;                 IF typ^.ref = 0 THEN OutStr(typ) END;                 IF varpar THEN WriteWord(RefFile, OBJ+varref)                   ELSE WriteWord(RefFile, OBJ+var)                 END;                 WriteWord(RefFile, typ^.ref);                 WriteWord(RefFile, vlev); WriteWord(RefFile, vadr)      | Temp   :      END;      WriteId(name)    END  END OutObj;  PROCEDURE OutLink;    VAR obj: ObjPtr;  BEGIN obj := Temps^.next;    WHILE obj # NIL DO      WITH obj^ DO        IF typ^.ref = 0 THEN OutExt(typ) END;        IF typ^.ref = 0 THEN OutStr(typ) END;        WriteWord(RefFile, CTL+linkage);        WriteWord(RefFile, typ^.ref);        WriteWord(RefFile, baseref)      END;      obj := obj^.next    END;    Temps^.next := NIL; Temps^.last := Temps  END OutLink;  PROCEDURE OutUnit(unit: ObjPtr);    VAR lev0, obj: ObjPtr;  BEGIN ALLOCATE(lev0, 0);    IF unit^.class = Proc THEN obj := unit^.firstLocal;      WHILE obj # NIL DO OutObj(obj); obj := obj^.next END;      OutLink;      WriteWord(RefFile, CTL+ProcTag);      WriteWord(RefFile, unit^.pd^.num);    ELSIF unit^.class = Module THEN obj := unit^.firstObj;      WHILE obj # NIL DO OutObj(obj); obj := obj^.next END;      OutLink;      WriteWord(RefFile, CTL+ModTag);      WriteWord(RefFile, unit^.modno)    END;    ResetHeap(lev0)  END OutUnit;  PROCEDURE RefPoint;    VAR pos: LONGINT;  BEGIN    GetPos(source, pos);    WriteWord(RefFile, pc);    WriteWord(RefFile, VAL(WORD, pos - oldPos));    oldPos := pos  END RefPoint;  PROCEDURE CloseRef(adr, pno: INTEGER);  BEGIN    WriteWord(RefFile, CTL+RefTag);    WriteWord(RefFile, adr); WriteWord(RefFile, pno);  END CloseRef;BEGIN  undftyp^.ref := 1; booltyp^.ref := 2; chartyp^.ref := 3; inttyp^.ref := 4;  cardtyp^.ref := 5; dbltyp^.ref := 6; realtyp^.ref := 7; lrltyp^.ref := 8;  bitstyp^.ref := 9; proctyp^.ref := 10; stringtyp^.ref := 11;  addrtyp^.ref := 12; bytetyp^.ref := 13; wordtyp^.ref := 14;  lcardtyp^.ref := 15;END M2RM. (* Copyright Departement Informatik, ETH Zuerich, Switzerland, 1992 *)